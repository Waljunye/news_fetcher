// Code generated by MockGen. DO NOT EDIT.
// Source: interfaces.go
//
// Generated by this command:
//
//	mockgen -source=interfaces.go -destination=mocks/mocks.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	domain "news_fetcher/internal/domain"
	reflect "reflect"
	time "time"

	gomock "go.uber.org/mock/gomock"
)

// MockArticleStore is a mock of ArticleStore interface.
type MockArticleStore struct {
	ctrl     *gomock.Controller
	recorder *MockArticleStoreMockRecorder
	isgomock struct{}
}

// MockArticleStoreMockRecorder is the mock recorder for MockArticleStore.
type MockArticleStoreMockRecorder struct {
	mock *MockArticleStore
}

// NewMockArticleStore creates a new mock instance.
func NewMockArticleStore(ctrl *gomock.Controller) *MockArticleStore {
	mock := &MockArticleStore{ctrl: ctrl}
	mock.recorder = &MockArticleStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockArticleStore) EXPECT() *MockArticleStoreMockRecorder {
	return m.recorder
}

// GetExistingBySourceAndExternalIDs mocks base method.
func (m *MockArticleStore) GetExistingBySourceAndExternalIDs(ctx context.Context, sourceID string, ids []int64) (map[int64]time.Time, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetExistingBySourceAndExternalIDs", ctx, sourceID, ids)
	ret0, _ := ret[0].(map[int64]time.Time)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetExistingBySourceAndExternalIDs indicates an expected call of GetExistingBySourceAndExternalIDs.
func (mr *MockArticleStoreMockRecorder) GetExistingBySourceAndExternalIDs(ctx, sourceID, ids any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetExistingBySourceAndExternalIDs", reflect.TypeOf((*MockArticleStore)(nil).GetExistingBySourceAndExternalIDs), ctx, sourceID, ids)
}

// Upsert mocks base method.
func (m *MockArticleStore) Upsert(ctx context.Context, article *domain.Article) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Upsert", ctx, article)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Upsert indicates an expected call of Upsert.
func (mr *MockArticleStoreMockRecorder) Upsert(ctx, article any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Upsert", reflect.TypeOf((*MockArticleStore)(nil).Upsert), ctx, article)
}

// MockTagStore is a mock of TagStore interface.
type MockTagStore struct {
	ctrl     *gomock.Controller
	recorder *MockTagStoreMockRecorder
	isgomock struct{}
}

// MockTagStoreMockRecorder is the mock recorder for MockTagStore.
type MockTagStoreMockRecorder struct {
	mock *MockTagStore
}

// NewMockTagStore creates a new mock instance.
func NewMockTagStore(ctrl *gomock.Controller) *MockTagStore {
	mock := &MockTagStore{ctrl: ctrl}
	mock.recorder = &MockTagStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTagStore) EXPECT() *MockTagStoreMockRecorder {
	return m.recorder
}

// LinkToArticle mocks base method.
func (m *MockTagStore) LinkToArticle(ctx context.Context, articleID int64, tagIDs []int64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LinkToArticle", ctx, articleID, tagIDs)
	ret0, _ := ret[0].(error)
	return ret0
}

// LinkToArticle indicates an expected call of LinkToArticle.
func (mr *MockTagStoreMockRecorder) LinkToArticle(ctx, articleID, tagIDs any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LinkToArticle", reflect.TypeOf((*MockTagStore)(nil).LinkToArticle), ctx, articleID, tagIDs)
}

// UpsertBatch mocks base method.
func (m *MockTagStore) UpsertBatch(ctx context.Context, tags []domain.Tag) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpsertBatch", ctx, tags)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpsertBatch indicates an expected call of UpsertBatch.
func (mr *MockTagStoreMockRecorder) UpsertBatch(ctx, tags any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertBatch", reflect.TypeOf((*MockTagStore)(nil).UpsertBatch), ctx, tags)
}

// MockSyncStateStore is a mock of SyncStateStore interface.
type MockSyncStateStore struct {
	ctrl     *gomock.Controller
	recorder *MockSyncStateStoreMockRecorder
	isgomock struct{}
}

// MockSyncStateStoreMockRecorder is the mock recorder for MockSyncStateStore.
type MockSyncStateStoreMockRecorder struct {
	mock *MockSyncStateStore
}

// NewMockSyncStateStore creates a new mock instance.
func NewMockSyncStateStore(ctrl *gomock.Controller) *MockSyncStateStore {
	mock := &MockSyncStateStore{ctrl: ctrl}
	mock.recorder = &MockSyncStateStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSyncStateStore) EXPECT() *MockSyncStateStoreMockRecorder {
	return m.recorder
}

// Get mocks base method.
func (m *MockSyncStateStore) Get(ctx context.Context, sourceID string) (*domain.SyncState, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, sourceID)
	ret0, _ := ret[0].(*domain.SyncState)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockSyncStateStoreMockRecorder) Get(ctx, sourceID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockSyncStateStore)(nil).Get), ctx, sourceID)
}

// Update mocks base method.
func (m *MockSyncStateStore) Update(ctx context.Context, state *domain.SyncState) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", ctx, state)
	ret0, _ := ret[0].(error)
	return ret0
}

// Update indicates an expected call of Update.
func (mr *MockSyncStateStoreMockRecorder) Update(ctx, state any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockSyncStateStore)(nil).Update), ctx, state)
}

// MockSource is a mock of Source interface.
type MockSource struct {
	ctrl     *gomock.Controller
	recorder *MockSourceMockRecorder
	isgomock struct{}
}

// MockSourceMockRecorder is the mock recorder for MockSource.
type MockSourceMockRecorder struct {
	mock *MockSource
}

// NewMockSource creates a new mock instance.
func NewMockSource(ctrl *gomock.Controller) *MockSource {
	mock := &MockSource{ctrl: ctrl}
	mock.recorder = &MockSourceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSource) EXPECT() *MockSourceMockRecorder {
	return m.recorder
}

// FetchArticles mocks base method.
func (m *MockSource) FetchArticles(ctx context.Context, maxPages int) ([]domain.Article, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchArticles", ctx, maxPages)
	ret0, _ := ret[0].([]domain.Article)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchArticles indicates an expected call of FetchArticles.
func (mr *MockSourceMockRecorder) FetchArticles(ctx, maxPages any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchArticles", reflect.TypeOf((*MockSource)(nil).FetchArticles), ctx, maxPages)
}

// ID mocks base method.
func (m *MockSource) ID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ID")
	ret0, _ := ret[0].(string)
	return ret0
}

// ID indicates an expected call of ID.
func (mr *MockSourceMockRecorder) ID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ID", reflect.TypeOf((*MockSource)(nil).ID))
}

// Name mocks base method.
func (m *MockSource) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name.
func (mr *MockSourceMockRecorder) Name() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockSource)(nil).Name))
}

// MockTransactionManager is a mock of TransactionManager interface.
type MockTransactionManager struct {
	ctrl     *gomock.Controller
	recorder *MockTransactionManagerMockRecorder
	isgomock struct{}
}

// MockTransactionManagerMockRecorder is the mock recorder for MockTransactionManager.
type MockTransactionManagerMockRecorder struct {
	mock *MockTransactionManager
}

// NewMockTransactionManager creates a new mock instance.
func NewMockTransactionManager(ctrl *gomock.Controller) *MockTransactionManager {
	mock := &MockTransactionManager{ctrl: ctrl}
	mock.recorder = &MockTransactionManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTransactionManager) EXPECT() *MockTransactionManagerMockRecorder {
	return m.recorder
}

// WithTransaction mocks base method.
func (m *MockTransactionManager) WithTransaction(ctx context.Context, fn func(context.Context) error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithTransaction", ctx, fn)
	ret0, _ := ret[0].(error)
	return ret0
}

// WithTransaction indicates an expected call of WithTransaction.
func (mr *MockTransactionManagerMockRecorder) WithTransaction(ctx, fn any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithTransaction", reflect.TypeOf((*MockTransactionManager)(nil).WithTransaction), ctx, fn)
}

// MockPublisher is a mock of Publisher interface.
type MockPublisher struct {
	ctrl     *gomock.Controller
	recorder *MockPublisherMockRecorder
	isgomock struct{}
}

// MockPublisherMockRecorder is the mock recorder for MockPublisher.
type MockPublisherMockRecorder struct {
	mock *MockPublisher
}

// NewMockPublisher creates a new mock instance.
func NewMockPublisher(ctrl *gomock.Controller) *MockPublisher {
	mock := &MockPublisher{ctrl: ctrl}
	mock.recorder = &MockPublisherMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPublisher) EXPECT() *MockPublisherMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockPublisher) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockPublisherMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockPublisher)(nil).Close))
}

// Publish mocks base method.
func (m *MockPublisher) Publish(ctx context.Context, article *domain.Article, isNew bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Publish", ctx, article, isNew)
	ret0, _ := ret[0].(error)
	return ret0
}

// Publish indicates an expected call of Publish.
func (mr *MockPublisherMockRecorder) Publish(ctx, article, isNew any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Publish", reflect.TypeOf((*MockPublisher)(nil).Publish), ctx, article, isNew)
}
